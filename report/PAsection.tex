\documentclass{article}

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{framed}

%% Simple AMSthm environments, numbered together.
\newtheorem{lem}{Lemma}
\newtheorem{thm}[lem]{Theorem}
\newtheorem{conj}[lem]{Conjecture}

\theoremstyle{definition}
\newtheorem{defn}[lem]{Definition}

\begin{document}

\subsubsection{Mathematical Flow Functions}
Like range analysis, pointer analysis is a `may' analysis. The domain of the analysis can be written as

\[ D = 2^{\{ x \rightarrow y \; |  \; x \in \text{Vars} \, \wedge \, y \in \text{Vars} \}}. \]

Top and bottom are the full set and the empty set, respectively. Thus, $top =\{ x \rightarrow y \; |  \; x \in \text{Vars} \, \wedge \, y \in \text{Vars} \}  $ and $\bot = \emptyset.$ Finally, we have $\sqsubseteq \, = \, \subseteq$, $\sqcup = \cup$, and $\sqcap = \cap$. The flow functions for pointer analysis can be written as follows

\begin{table} 
\centering % used for centering table 
\begin{tabular}{c | c} % centered columns (4 columns) 
Function & Output \\ [0.5ex] % inserts table 
%heading 
\hline % inserts single horizontal line 
$F_{X = C}(in)$ & $in \setminus \{ X \rightarrow * \}$ \\ % inserting body of the table 
$F_{X = Y + Z}(in)$ & $in \setminus \{ X \rightarrow * \}$ \\ 
$F_{X = Y}(in)$ & $in \setminus \{ X \rightarrow * \} \cup \{ X \rightarrow Z \, | \, Y \rightarrow Z \in in \}$ \\ 
$F_{X =  \& Y}(in)$ & $in \setminus \{ X \rightarrow * \} \cup \{ X \rightarrow Y \}$\\ 
$F_{X = *Y}(in)$ & $in \setminus \{ X \rightarrow * \} \cup \{ X \rightarrow B \; | \; \exists A \in \text{Vars s.t. }  Y \rightarrow A \in in \, \wedge \, A \rightarrow B \in in \}$\\
$F_{*X = Y}(in)$ & $in \setminus \{ X \rightarrow * \} \cup \{ A \rightarrow B \; | \; \exists B \in \text{Vars s.t. } X \rightarrow A \in in \, \wedge \, Y \rightarrow B \in in\}$\\ [1ex] % [1ex] adds vertical space 
\hline %inserts single line 
\end{tabular} 
\label{table:PAFlowFuncs} % is used to refer this table in the text 
\end{table} 

%\[ F_{X = C}(in) = in \setminus \{ X \rightarrow * \} \]
%
%\[ F_{X = Y + Z}(in) = in \setminus \{ X \rightarrow * \} \]
%
%\[ F_{X = Y}(in) = in \setminus \{ X \rightarrow * \} \cup \{ X \rightarrow Z \, | \, Y \rightarrow Z \in in \}\]
%
%\[ F_{X =  \& Y}(in) = in \setminus \{ X \rightarrow * \} \cup \{ X \rightarrow Y \}\]
%
%\[ F_{X = *Y}(in) = in \setminus \{ X \rightarrow * \} \cup \{ X \rightarrow B \; | \; \exists A \in \text{Vars s.t. }  Y \rightarrow A \in in \, \wedge \, A \rightarrow B \in in \}\]
%
%\[ F_{*X = Y}(in) = in \setminus \{ X \rightarrow * \} \cup \{ A \rightarrow B \; | \; \exists B \in \text{Vars s.t. } X \rightarrow A \in in \, \wedge \, Y \rightarrow B \in in\}\]


\subsubsection{Implementation Considerations}
\begin{framed}
  discuss how you actually went about implementing the lattice and
  flow functions. For instance, some interesting questions are: what
  data structure(s) did you use, and how do you represent potentially
  infinite sets? How are input facts passed to your flow functions,
  and how do output facts get propagated?
\end{framed}

\end{document}

